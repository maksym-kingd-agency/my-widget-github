{"version":3,"file":"670.js","mappings":"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","sources":["webpack:///../../node_modules/use-supercluster/dist/index.js","webpack:///../../node_modules/use-supercluster/dist/use-supercluster.cjs.production.min.js","webpack:///../../node_modules/kdbush/index.js","webpack:///../../node_modules/supercluster/index.js"],"sourcesContent":["\n'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./use-supercluster.cjs.production.min.js')\n} else {\n  module.exports = require('./use-supercluster.cjs.development.js')\n}\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0});var e,r=require(\"react\"),u=(e=require(\"supercluster\"))&&\"object\"==typeof e&&\"default\"in e?e.default:e,t=require(\"use-deep-compare-effect\"),s=require(\"dequal\");exports.default=function(e){var c=e.points,n=e.bounds,o=e.zoom,a=e.options,f=r.useRef(),l=r.useRef(),p=r.useState([]),d=p[0],i=p[1],q=Math.round(o);return t.useDeepCompareEffectNoCheck((function(){f.current&&s.dequal(l.current,c)&&s.dequal(f.current.options,a)||(f.current=new u(a),f.current.load(c)),n&&i(f.current.getClusters(n,q)),l.current=c}),[c,n,q,a]),{clusters:d,supercluster:f.current}};\n//# sourceMappingURL=use-supercluster.cjs.production.min.js.map\n","\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nconst VERSION = 1; // serialized format version\nconst HEADER_SIZE = 8;\n\nexport default class KDBush {\n\n    /**\n     * Creates an index from raw `ArrayBuffer` data.\n     * @param {ArrayBuffer} data\n     */\n    static from(data) {\n        if (!(data instanceof ArrayBuffer)) {\n            throw new Error('Data must be an instance of ArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xdb) {\n            throw new Error('Data does not appear to be in a KDBush format.');\n        }\n        const version = versionAndType >> 4;\n        if (version !== VERSION) {\n            throw new Error(`Got v${version} data when expected v${VERSION}.`);\n        }\n        const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n        if (!ArrayType) {\n            throw new Error('Unrecognized array type.');\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new KDBush(numItems, nodeSize, ArrayType, data);\n    }\n\n    /**\n     * Creates an index that will hold a given number of items.\n     * @param {number} numItems\n     * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).\n     * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n     * @param {ArrayBuffer} [data] (For internal use only)\n     */\n    constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {\n        if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n        const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n        const padCoords = (8 - idsByteSize % 8) % 8;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data && (data instanceof ArrayBuffer)) { // reconstruct an index from a buffer\n            this.data = data;\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = numItems * 2;\n            this._finished = true;\n        } else { // initialize a new index\n            this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = 0;\n            this._finished = false;\n\n            // set header\n            new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n    }\n\n    /**\n     * Add a point to the index.\n     * @param {number} x\n     * @param {number} y\n     * @returns {number} An incremental index associated with the added item (starting from `0`).\n     */\n    add(x, y) {\n        const index = this._pos >> 1;\n        this.ids[index] = index;\n        this.coords[this._pos++] = x;\n        this.coords[this._pos++] = y;\n        return index;\n    }\n\n    /**\n     * Perform indexing of the added points.\n     */\n    finish() {\n        const numAdded = this._pos >> 1;\n        if (numAdded !== this.numItems) {\n            throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n        }\n        // kd-sort both arrays for efficient search\n        sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n\n        this._finished = true;\n        return this;\n    }\n\n    /**\n     * Search the index for items within a given bounding box.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    range(minX, minY, maxX, maxY) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n\n        // recursively search for items in range in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    const x = coords[2 * i];\n                    const y = coords[2 * i + 1];\n                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? minX <= x : minY <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? maxX >= x : maxY >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Search the index for items within a given radius.\n     * @param {number} qx\n     * @param {number} qy\n     * @param {number} r Query radius.\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    within(qx, qy, r) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n        const r2 = r * r;\n\n        // recursively search for items within radius in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? qx - r <= x : qy - r <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? qx + r >= x : qy + r >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} nodeSize\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction sort(ids, coords, nodeSize, left, right, axis) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1; // middle index\n\n    // sort ids and coords around the middle index so that the halves lie\n    // either left/right or top/bottom correspondingly (taking turns)\n    select(ids, coords, m, left, right, axis);\n\n    // recursively kd-sort first half and second half on the opposite axis\n    sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n    sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\n/**\n * Custom Floyd-Rivest selection algorithm: sort ids and coords so that\n * [left..k-1] items are smaller than k-th item (on either x or y axis)\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} k\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction select(ids, coords, k, left, right, axis) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, axis);\n        }\n\n        const t = coords[2 * k + axis];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + axis] < t) i++;\n            while (coords[2 * j + axis] > t) j--;\n        }\n\n        if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} i\n * @param {number} j\n */\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\n/**\n * @param {InstanceType<TypedArrayConstructor>} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @param {number} ax\n * @param {number} ay\n * @param {number} bx\n * @param {number} by\n */\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst OFFSET_PROP = 6;\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = Object.assign(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n        this.stride = this.options.reduce ? 7 : 6;\n        this.clusterProps = [];\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        const data = [];\n\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            if (!p.geometry) continue;\n\n            const [lng, lat] = p.geometry.coordinates;\n            const x = fround(lngX(lng));\n            const y = fround(latY(lat));\n            // store internal point/cluster data in flat numeric arrays for performance\n            data.push(\n                x, y, // projected point coordinates\n                Infinity, // the last zoom the point was processed at\n                i, // index of the source feature in the original input array\n                -1, // parent cluster id\n                1 // number of points in a cluster\n            );\n            if (this.options.reduce) data.push(0); // noop\n        }\n        let tree = this.trees[maxZoom + 1] = this._createTree(data);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n\n            if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const data = tree.data;\n        const clusters = [];\n        for (const id of ids) {\n            const k = this.stride * id;\n            clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const tree = this.trees[originZoom];\n        if (!tree) throw new Error(errorMsg);\n\n        const data = tree.data;\n        if (originId * this.stride >= data.length) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const x = data[originId * this.stride];\n        const y = data[originId * this.stride + 1];\n        const ids = tree.within(x, y, r);\n        const children = [];\n        for (const id of ids) {\n            const k = id * this.stride;\n            if (data[k + OFFSET_PARENT] === clusterId) {\n                children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.data, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.data, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.data, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _createTree(data) {\n        const tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n        tree.finish();\n        tree.data = data;\n        return tree;\n    }\n\n    _addTileFeatures(ids, data, x, y, z2, tile) {\n        for (const i of ids) {\n            const k = i * this.stride;\n            const isCluster = data[k + OFFSET_NUM] > 1;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(data, k, this.clusterProps);\n                px = data[k];\n                py = data[k + 1];\n            } else {\n                const p = this.points[data[k + OFFSET_ID]];\n                tags = p.properties;\n                const [lng, lat] = p.geometry.coordinates;\n                px = lngX(lng);\n                py = latY(lat);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster || this.options.generateId) {\n                // optionally generate id for points\n                id = data[k + OFFSET_ID];\n            } else {\n                // keep id if already assigned\n                id = this.points[data[k + OFFSET_ID]].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(tree, zoom) {\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n        const data = tree.data;\n        const nextData = [];\n        const stride = this.stride;\n\n        // loop through each point\n        for (let i = 0; i < data.length; i += stride) {\n            // if we've already visited the point at this zoom level, skip it\n            if (data[i + OFFSET_ZOOM] <= zoom) continue;\n            data[i + OFFSET_ZOOM] = zoom;\n\n            // find all nearby points\n            const x = data[i];\n            const y = data[i + 1];\n            const neighborIds = tree.within(data[i], data[i + 1], r);\n\n            const numPointsOrigin = data[i + OFFSET_NUM];\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const k = neighborId * stride;\n                // filter out neighbors that are already processed\n                if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = x * numPointsOrigin;\n                let wy = y * numPointsOrigin;\n\n                let clusterProperties;\n                let clusterPropIndex = -1;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const k = neighborId * stride;\n\n                    if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                    data[k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = data[k + OFFSET_NUM];\n                    wx += data[k] * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += data[k + 1] * numPoints2;\n\n                    data[k + OFFSET_PARENT] = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) {\n                            clusterProperties = this._map(data, i, true);\n                            clusterPropIndex = this.clusterProps.length;\n                            this.clusterProps.push(clusterProperties);\n                        }\n                        reduce(clusterProperties, this._map(data, k));\n                    }\n                }\n\n                data[i + OFFSET_PARENT] = id;\n                nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n                if (reduce) nextData.push(clusterPropIndex);\n\n            } else { // left points as unclustered\n                for (let j = 0; j < stride; j++) nextData.push(data[i + j]);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const k = neighborId * stride;\n                        if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                        data[k + OFFSET_ZOOM] = zoom;\n                        for (let j = 0; j < stride; j++) nextData.push(data[k + j]);\n                    }\n                }\n            }\n        }\n\n        return nextData;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(data, i, clone) {\n        if (data[i + OFFSET_NUM] > 1) {\n            const props = this.clusterProps[data[i + OFFSET_PROP]];\n            return clone ? Object.assign({}, props) : props;\n        }\n        const original = this.points[data[i + OFFSET_ID]].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? Object.assign({}, result) : result;\n    }\n}\n\nfunction getClusterJSON(data, i, clusterProps) {\n    return {\n        type: 'Feature',\n        id: data[i + OFFSET_ID],\n        properties: getClusterProperties(data, i, clusterProps),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(data[i]), yLat(data[i + 1])]\n        }\n    };\n}\n\nfunction getClusterProperties(data, i, clusterProps) {\n    const count = data[i + OFFSET_NUM];\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    const propIndex = data[i + OFFSET_PROP];\n    const properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n    return Object.assign(properties, {\n        cluster: true,\n        cluster_id: data[i + OFFSET_ID],\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n"],"names":["process","module","exports","require","Object","defineProperty","value","e","r","u","default","t","s","c","points","n","bounds","o","zoom","a","options","f","useRef","l","p","useState","d","i","q","Math","round","useDeepCompareEffectNoCheck","current","dequal","load","getClusters","clusters","supercluster","ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","VERSION","HEADER_SIZE","KDBush","from","data","ArrayBuffer","Error","magic","versionAndType","version","ArrayType","nodeSize","numItems","constructor","isNaN","min","max","IndexArrayType","arrayTypeIndex","indexOf","coordsByteSize","BYTES_PER_ELEMENT","idsByteSize","padCoords","ids","coords","_pos","_finished","set","add","x","y","index","finish","numAdded","sort","range","minX","minY","maxX","maxY","stack","length","result","axis","pop","right","left","push","m","within","qx","qy","r2","sqDist","select","k","z","log","exp","sd","sqrt","newLeft","floor","newRight","j","swapItem","swap","arr","tmp","ax","ay","bx","by","dx","dy","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","fround","OFFSET_ZOOM","OFFSET_ID","OFFSET_PARENT","OFFSET_NUM","OFFSET_PROP","Supercluster","assign","create","trees","Array","stride","clusterProps","console","time","timerId","geometry","lng","lat","coordinates","lngX","latY","Infinity","tree","_createTree","timeEnd","now","Date","_cluster","bbox","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","_limitZoom","id","getClusterJSON","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","pow","children","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","isCluster","tags","px","py","getClusterProperties","type","undefined","nextData","neighborIds","numPointsOrigin","numPoints","neighborId","wx","wy","clusterProperties","clusterPropIndex","numPoints2","_map","clone","original","xLng","yLat","count","abbrev","propIndex","point_count_abbreviated","sin","PI","y2","atan"],"sourceRoot":""}